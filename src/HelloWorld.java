import java.util.Scanner;

public class HelloWorld {
    public static void main(String[] args) {
//        System.out.print("Hello ");
//        System.out.print("World! \n");
//
//        // 1
//        int myFavoriteNumber = 45;
//        System.out.println("My favorite number: " + myFavoriteNumber);
//        int testNumber;
//        testNumber = 1;
//        System.out.println(testNumber);

//        // 2
//        String myString = "3.1459";
//        System.out.println(myString);
//        double myNumber = 3.14;
//        System.out.println(myNumber);
//        int x = 5;
//
//        //System.out.println(x++);
//        //System.out.println(x);
//        //The above prints 5 and then 6 because x is incremented after the print, which is picked up by the second print
//        System.out.println(++x);
//        System.out.println(x);
//        //The above prints 6 twice because x is pre-incremented before printing
//
//        //11: Class is a reserved keyword - cannot assign it as a variable name
//
//        String theNumberThree = "three";
//        Object o = theNumberThree;
//        int three = (int) o;
//        //int three = (int) "three";
//        //System.out.println(three);
//
//        //Explanation: Trying to caste a string into an object, and then an object into an integer. This is an ILLEGAL casting - impossible to do. Not sure what the second error is - looks like all the errors involve casting behavior
//        //Difference - runtime vs compile time
//
//        int y = 4;
//        y += 5;
//        System.out.println(y);
//        int a = 3;
//        int b = 4;
//        b *= a;
//        System.out.println(b);
//        int c = 10;
//        int d = 2;
//        c /= d;
//        System.out.println(c);
//        d -= c;
//        System.out.println(d);
//
//
//
//        byte testNum = Byte.MAX_VALUE;
//        System.out.println(++testNum);
//        //14.1.a: If the value is larger than the numerical variable it's being assigned to, it will throw an error - you cannot store large to small unless you explicitly coerce it?
//        //14.1.b: If the value is smaller than the numerical variable it's being assigned to, there shouldn't be an issue - you can go small into big
//        //14.2: No clue - it rolls back to the type's smallest value (David ex: arcade game: once you hit highest score, it rolls back to 0's across the board)
//    }

//    public static int addInts001(int a, int b) {
//        return a + b;
//    }
//
//
//    public static double performIndicatedOperation011(String operation, double op1, double op2) {
//        if (operation.equals("ADD")) {
//            results = op1 + op2;
//        } else if (operation.equals("SUB")) {
//            results = op1 - op2;
//        } else if (operation.equals("MUL")) {
//            results =  op1 * op2;
//        } else if (operation.equals("DIV")) {
//            results = op1 / op2;
//        } else {
//            results = 0;
//        }
//        return results;
//    }
//
//    public static int getNearestIntegerToRealSum013(double firstRealAddend, double secondRealAddend) {
//        results = (int) Math.round(firstRealAddend + secondRealAddend);
//        return results;

    }
}


